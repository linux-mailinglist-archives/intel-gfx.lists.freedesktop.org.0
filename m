Return-Path: <intel-gfx-bounces@lists.freedesktop.org>
X-Original-To: lists+intel-gfx@lfdr.de
Delivered-To: lists+intel-gfx@lfdr.de
Received: from gabe.freedesktop.org (gabe.freedesktop.org [131.252.210.177])
	by mail.lfdr.de (Postfix) with ESMTPS id 1116070E47F
	for <lists+intel-gfx@lfdr.de>; Tue, 23 May 2023 20:21:03 +0200 (CEST)
Received: from gabe.freedesktop.org (localhost [127.0.0.1])
	by gabe.freedesktop.org (Postfix) with ESMTP id 7533010E496;
	Tue, 23 May 2023 18:20:58 +0000 (UTC)
X-Original-To: intel-gfx@lists.freedesktop.org
Delivered-To: intel-gfx@lists.freedesktop.org
Received: from mga09.intel.com (mga09.intel.com [134.134.136.24])
 by gabe.freedesktop.org (Postfix) with ESMTPS id 53ECC10E496
 for <intel-gfx@lists.freedesktop.org>; Tue, 23 May 2023 18:20:56 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
 d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
 t=1684866056; x=1716402056;
 h=date:message-id:from:to:cc:subject:in-reply-to:
 references:mime-version;
 bh=pDjNiWEQtO0ejNsyKR+OZVQyEofie+Oy89g18yjYrgU=;
 b=MTLAngC4RavO0enUn0GZ8+MkhKhg00CWhp72xHpMGGoA1X1dLfycEz9U
 KaLehzq0CrYuHiTIxE0UNNX+0iagMfxRSfqBMXm6ltA9ORxBhCzHfvhcm
 U6/L70DXd+wPIMlPu7+ma5/pD6XhDP2BU2NStRowKQ9e02GRq3d6R8cnO
 GuQb6ELXU1SWCZkd3zGSFExTSMPId0S5GMsPNRSDibijFE8IhCT3vUDXo
 QHISx1z+rdnCESeGRNa7TM9VenmXgBaPrRGmVRit9/hnzCZZvM05B3ZkI
 YHzxILa2peGBXuEtH10pu5btx/Bvl2XfkxRTwC1QTwVy8wCWzWvFnSKwV w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10719"; a="355678003"
X-IronPort-AV: E=Sophos;i="6.00,187,1681196400"; d="scan'208";a="355678003"
Received: from orsmga003.jf.intel.com ([10.7.209.27])
 by orsmga102.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384;
 23 May 2023 11:20:55 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10719"; a="654474695"
X-IronPort-AV: E=Sophos;i="6.00,187,1681196400"; d="scan'208";a="654474695"
Received: from adixit-mobl.amr.corp.intel.com (HELO adixit-arch.intel.com)
 ([10.209.19.91])
 by orsmga003-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384;
 23 May 2023 11:20:54 -0700
Date: Tue, 23 May 2023 11:20:54 -0700
Message-ID: <87ilcirjsp.wl-ashutosh.dixit@intel.com>
From: "Dixit, Ashutosh" <ashutosh.dixit@intel.com>
To: Umesh Nerlige Ramappa <umesh.nerlige.ramappa@intel.com>
In-Reply-To: <ZGvn6vTwgEz7I5h/@orsosgc001.jf.intel.com>
References: <20230519225642.134778-1-umesh.nerlige.ramappa@intel.com>	<87mt1wqfsz.wl-ashutosh.dixit@intel.com>	<ZGvn6vTwgEz7I5h/@orsosgc001.jf.intel.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?ISO-8859-4?Q?Goj=F2?=) APEL-LB/10.8 EasyPG/1.0.0
 Emacs/28.2 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
Subject: Re: [Intel-gfx] [PATCH] i915/perf: Avoid reading OA reports before
 they land
X-BeenThere: intel-gfx@lists.freedesktop.org
X-Mailman-Version: 2.1.29
Precedence: list
List-Id: Intel graphics driver community testing & development
 <intel-gfx.lists.freedesktop.org>
List-Unsubscribe: <https://lists.freedesktop.org/mailman/options/intel-gfx>,
 <mailto:intel-gfx-request@lists.freedesktop.org?subject=unsubscribe>
List-Archive: <https://lists.freedesktop.org/archives/intel-gfx>
List-Post: <mailto:intel-gfx@lists.freedesktop.org>
List-Help: <mailto:intel-gfx-request@lists.freedesktop.org?subject=help>
List-Subscribe: <https://lists.freedesktop.org/mailman/listinfo/intel-gfx>,
 <mailto:intel-gfx-request@lists.freedesktop.org?subject=subscribe>
Cc: Lionel G Landwerlin <lionel.g.landwerlin@linux.intel.com>,
 intel-gfx@lists.freedesktop.org
Errors-To: intel-gfx-bounces@lists.freedesktop.org
Sender: "Intel-gfx" <intel-gfx-bounces@lists.freedesktop.org>

On Mon, 22 May 2023 15:08:42 -0700, Umesh Nerlige Ramappa wrote:
>

Hi Umesh,

> On Mon, May 22, 2023 at 01:20:12PM -0700, Dixit, Ashutosh wrote:
> > On Fri, 19 May 2023 15:56:42 -0700, Umesh Nerlige Ramappa wrote:
> >>
> >> On DG2, capturing OA reports while running heavy render workloads
> >> sometimes results in invalid OA reports where 64-byte chunks inside
> >> reports have stale values. Under memory pressure, high OA sampling rates
> >> (13.3 us) and heavy render workload, occassionally, the OA HW TAIL
> >> pointer does not progress as fast as the sampling rate. When these
> >> glitches occur, the TAIL pointer takes approx. 200us to progress.  While
> >> this is expected behavior from the HW perspective, invalid reports are
> >> not expected.
> >>
> >> In oa_buffer_check_unlocked(), when we execute the if condition, we are
> >> updating the oa_buffer.tail to the aging tail and then setting pollin
> >> based on this tail value, however, we do not have a chance to rewind and
> >> validate the reports prior to setting pollin. The validation happens
> >> in a subsequent call to oa_buffer_check_unlocked(). If a read occurs
> >> before this validation, then we end up reading reports up until this
> >> oa_buffer.tail value which includes invalid reports. Though found on
> >> DG2, this affects all platforms.
> >>
> >> Set the pollin only in the else condition in oa_buffer_check_unlocked.
> >>
> >> Bug: https://gitlab.freedesktop.org/drm/intel/-/issues/7484
> >> Bug: https://gitlab.freedesktop.org/drm/intel/-/issues/7757
> >> Signed-off-by: Umesh Nerlige Ramappa <umesh.nerlige.ramappa@intel.com>
> >> ---
> >>  drivers/gpu/drm/i915/i915_perf.c | 8 ++++----
> >>  1 file changed, 4 insertions(+), 4 deletions(-)
> >>
> >> diff --git a/drivers/gpu/drm/i915/i915_perf.c b/drivers/gpu/drm/i915/i915_perf.c
> >> index 19d5652300ee..61536e3c4ac9 100644
> >> --- a/drivers/gpu/drm/i915/i915_perf.c
> >> +++ b/drivers/gpu/drm/i915/i915_perf.c
> >> @@ -545,7 +545,7 @@ static bool oa_buffer_check_unlocked(struct i915_perf_stream *stream)
> >>	u32 gtt_offset = i915_ggtt_offset(stream->oa_buffer.vma);
> >>	int report_size = stream->oa_buffer.format->size;
> >>	unsigned long flags;
> >> -	bool pollin;
> >> +	bool pollin = false;
> >>	u32 hw_tail;
> >>	u64 now;
> >>	u32 partial_report_size;
> >> @@ -620,10 +620,10 @@ static bool oa_buffer_check_unlocked(struct i915_perf_stream *stream)
> >>		stream->oa_buffer.tail = gtt_offset + tail;
> >>		stream->oa_buffer.aging_tail = gtt_offset + hw_tail;
> >>		stream->oa_buffer.aging_timestamp = now;
> >> -	}
> >>
> >> -	pollin = OA_TAKEN(stream->oa_buffer.tail - gtt_offset,
> >> -			  stream->oa_buffer.head - gtt_offset) >= report_size;
> >> +		pollin = OA_TAKEN(stream->oa_buffer.tail - gtt_offset,
> >> +				  stream->oa_buffer.head - gtt_offset) >= report_size;
> >> +	}
> >
> > The issue has been correctly identified above. But seems that the real
> > cause for the issue is not that pollin statement above is misplaced but
> > that updating the tail via aging is unreliable (at least with the present
> > timeout as you mention above). Also, it is not clear why we have tail aging
> > at all, since it seems we can detect when reports land (by checking
> > report_id and timestamp). So rather than move the pollin into the else, we
> > should just eliminate the if () part. And if we are eliminating the if ()
> > we can just eliminate the concept of tail aging from the code (and
> > comments) and rely solely on explicit detection of reports landing.

I missed this yesterday but the above patch is basically incorrect. We need
to return pollin true when we have a "non-zero distance between head and
tail", i.e. when there is data to be read. And we have violated this for
the if () part with this patch (because we are unconditionally returning
false from the if () even when there is data to be read). So there are only
two ways to solve this:

a. Increase OA_TAIL_MARGIN_NSEC (the aging time)
b. Eliminate tail aging (i.e. eliminate the if ())

We cannot move the pollin statement into the else.

The preferred way is b. since it makes the overall code consistent
again. And it seems easy enough to do.

> I thought so too, it would be much simpler code. Looks like Lionel agrees
> with removing this code as well.
> I do have a couple concerns though.
>
> - In the blocking case, i915_perf_read() path waits on a queue with the
> condition being oa_buffer_check_unlocked(). If sampling rate is high,
> oa_buffer_check_unlocked will almost always return true. If we remove the
> if block, we may run the rewind logic too often to detect reports that
> landed. The aging logic is just giving a 100us buffer to avoid repeated
> checks here if tail hasn't moved. (although tbh, 100 us is very small).

I am pretty sure if we eliminate tail aging, we would fairly easily be able
to solve the problem of rewind logic running too often (e.g. put an 'if
(hw_tail != oa_buffer.tail) around the rewind logic etc).

> - The other concern - by dropping all this aging logic, are we changing
> underlying behavior?

I don't think eliminating tail aging makes a significant change to
underlying behavior from what we have today (and I doubt we worried about
changing underlying behavior when we implemented explicit detection of
reports landing in d1df41eb72ef).

>
> - Is there a significant ROI on current patch vs. dropping all the aging
> logic?

Yes, the biggest ROI for me is to have the code make sense again (the code
is incomprehensible the moment you ask "why do we the concept of tail aging
when we can explicitly detect reports landing?"). And anyway as I mentioned
above the current patch is just incorrect so we need a different solution
anyway.

Thanks.
--
Ashutosh

> > Separately, there seems to be another related bug in the code, I have sent
> > a patch for that here:
> >
> > https://patchwork.freedesktop.org/series/118151/
>
> That's a valid new issue and different from this one, but related to the
> rewind logic. lgtm.
>
> Thanks,
> Umesh
> >
> > Thanks.
> > --
> > Ashutosh

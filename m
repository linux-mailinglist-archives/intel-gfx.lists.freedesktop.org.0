Return-Path: <intel-gfx-bounces@lists.freedesktop.org>
X-Original-To: lists+intel-gfx@lfdr.de
Delivered-To: lists+intel-gfx@lfdr.de
Received: from gabe.freedesktop.org (gabe.freedesktop.org [IPv6:2610:10:20:722:a800:ff:fe36:1795])
	by mail.lfdr.de (Postfix) with ESMTPS id EC9DC508D18
	for <lists+intel-gfx@lfdr.de>; Wed, 20 Apr 2022 18:20:07 +0200 (CEST)
Received: from gabe.freedesktop.org (localhost [127.0.0.1])
	by gabe.freedesktop.org (Postfix) with ESMTP id 06B3310E222;
	Wed, 20 Apr 2022 16:20:06 +0000 (UTC)
X-Original-To: intel-gfx@lists.freedesktop.org
Delivered-To: intel-gfx@lists.freedesktop.org
Received: from mga18.intel.com (mga18.intel.com [134.134.136.126])
 by gabe.freedesktop.org (Postfix) with ESMTPS id E5DB310E222
 for <intel-gfx@lists.freedesktop.org>; Wed, 20 Apr 2022 16:20:03 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
 d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
 t=1650471604; x=1682007604;
 h=date:message-id:from:to:cc:subject:in-reply-to:
 references:mime-version;
 bh=OfeM/9xlISXwsIw8tU3+f6CQukYzyxZHRsFlNF5lO0w=;
 b=NhexFO4Xb1hO0AzceN2toxSWgYQ32Ay1uNv2hWlu7HZTj2K5RKzZnZmg
 vAkMAD/SaQJ3p6s3FG0bqunK2ZAKhF6bVtSzRusb+vDKsjRlHvdqLkO46
 jp+hMJI8djY275ZsZFpP651wh2zDnoPMujNnsNufFNx15dVRMtUjhEDga
 bPLCm4zVPeGYlHKkNpaVUkZahcj4/nwfVpEF9XAFed7Pt0brkIn1f8U8a
 tkGEJ1HRP7Y0vTQx5l+UAXSRxPTdwTQcR9kqB8MRJTF8IyhcLi6xyUUb/
 9GHGX8vE2qk3GIS1fBn+0TjvTwnY2ezTi8A14y9zXGIJXOX1MIEzHeha1 A==;
X-IronPort-AV: E=McAfee;i="6400,9594,10323"; a="245969361"
X-IronPort-AV: E=Sophos;i="5.90,276,1643702400"; d="scan'208";a="245969361"
Received: from orsmga007.jf.intel.com ([10.7.209.58])
 by orsmga106.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384;
 20 Apr 2022 09:12:57 -0700
X-IronPort-AV: E=Sophos;i="5.90,276,1643702400"; d="scan'208";a="555271609"
Received: from adixit-mobl1.amr.corp.intel.com (HELO adixit-arch.intel.com)
 ([10.212.215.49])
 by orsmga007-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384;
 20 Apr 2022 09:12:57 -0700
Date: Wed, 20 Apr 2022 09:12:57 -0700
Message-ID: <87levzag3a.wl-ashutosh.dixit@intel.com>
From: "Dixit, Ashutosh" <ashutosh.dixit@intel.com>
To: Andrzej Hajda <andrzej.hajda@intel.com>
In-Reply-To: <1339a2be-5fd0-cf65-d361-06c60d938ce5@intel.com>
References: <cover.1649871650.git.ashutosh.dixit@intel.com>	<cover.1650430271.git.ashutosh.dixit@intel.com>	<9ed5af1177ad08c7c2d9c5d9b32ab0154dbd950f.1650430271.git.ashutosh.dixit@intel.com>	<1339a2be-5fd0-cf65-d361-06c60d938ce5@intel.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?ISO-8859-4?Q?Goj=F2?=) APEL-LB/10.8 EasyPG/1.0.0
 Emacs/27.2 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
Subject: Re: [Intel-gfx] [PATCH 7/9] drm/i915/gt: Fix memory leaks in per-gt
 sysfs
X-BeenThere: intel-gfx@lists.freedesktop.org
X-Mailman-Version: 2.1.29
Precedence: list
List-Id: Intel graphics driver community testing & development
 <intel-gfx.lists.freedesktop.org>
List-Unsubscribe: <https://lists.freedesktop.org/mailman/options/intel-gfx>,
 <mailto:intel-gfx-request@lists.freedesktop.org?subject=unsubscribe>
List-Archive: <https://lists.freedesktop.org/archives/intel-gfx>
List-Post: <mailto:intel-gfx@lists.freedesktop.org>
List-Help: <mailto:intel-gfx-request@lists.freedesktop.org?subject=help>
List-Subscribe: <https://lists.freedesktop.org/mailman/listinfo/intel-gfx>,
 <mailto:intel-gfx-request@lists.freedesktop.org?subject=subscribe>
Cc: intel-gfx@lists.freedesktop.org, Andi Shyti <andi.shyti@intel.com>,
 Rodrigo Vivi <rodrigo.vivi@intel.com>
Errors-To: intel-gfx-bounces@lists.freedesktop.org
Sender: "Intel-gfx" <intel-gfx-bounces@lists.freedesktop.org>

On Wed, 20 Apr 2022 05:17:57 -0700, Andrzej Hajda wrote:
>
> Hi Ashutosh,

Hi Andrzej,

> On 20.04.2022 07:21, Ashutosh Dixit wrote:
> > All kmalloc'd kobjects need a kobject_put() to free memory. For example in
> > previous code, kobj_gt_release() never gets called. The requirement of
> > kobject_put() now results in a slightly different code organization.
> >
> > Cc: Andi Shyti <andi.shyti@intel.com>
> > Cc: Andrzej Hajda <andrzej.hajda@intel.com>
> > Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
> > Fixes: b770bcfae9ad ("drm/i915/gt: create per-tile sysfs interface")

/snip/

> > +void intel_gt_sysfs_unregister(struct intel_gt *gt)
> > +{
> > +	kobject_put(&gt->sysfs_gtn);
> > +}
> > diff --git a/drivers/gpu/drm/i915/gt/intel_gt_sysfs.h b/drivers/gpu/drm/i915/gt/intel_gt_sysfs.h
> > index 9471b26752cf..a99aa7e8b01a 100644
> > --- a/drivers/gpu/drm/i915/gt/intel_gt_sysfs.h
> > +++ b/drivers/gpu/drm/i915/gt/intel_gt_sysfs.h
> > @@ -13,11 +13,6 @@
> >     struct intel_gt;
> >   -struct kobj_gt {
> > -	struct kobject base;
> > -	struct intel_gt *gt;
> > -};
> > -
> >   bool is_object_gt(struct kobject *kobj);
> >     struct drm_i915_private *kobj_to_i915(struct kobject *kobj);
> > @@ -28,6 +23,7 @@ intel_gt_create_kobj(struct intel_gt *gt,
> >		     const char *name);
> >     void intel_gt_sysfs_register(struct intel_gt *gt);
> > +void intel_gt_sysfs_unregister(struct intel_gt *gt);
> >   struct intel_gt *intel_gt_sysfs_get_drvdata(struct device *dev,
> >					    const char *name);
> >   diff --git a/drivers/gpu/drm/i915/gt/intel_gt_types.h
> > b/drivers/gpu/drm/i915/gt/intel_gt_types.h
> > index 937b2e1a305e..4c72b4f983a6 100644
> > --- a/drivers/gpu/drm/i915/gt/intel_gt_types.h
> > +++ b/drivers/gpu/drm/i915/gt/intel_gt_types.h
> > @@ -222,6 +222,9 @@ struct intel_gt {
> >	} mocs;
> >		struct intel_pxp pxp;
> > +
> > +	/* gt/gtN sysfs */
> > +	struct kobject sysfs_gtn;
>
> If you put kobject as a part of intel_gt what assures you that lifetime of
> kobject is shorter than intel_gt? Ie its refcounter is 0 on removal of
> intel_gt?

Because we are explicitly doing a kobject_put() in
intel_gt_sysfs_unregister(). Which is exactly what we are *not* doing in
the previous code.

Let me explain a bit about the previous code (but feel free to skip since
the patch should speak for itself):
* Previously we kzalloc a 'struct kobj_gt'
* But we don't save a pointer to the 'struct kobj_gt' so we don't have the
  pointer to the kobject to be able to do a kobject_put() on it later
* Therefore we need to store the pointer in 'struct intel_gt'
* But if we have to put the pointer in 'struct intel_gt' we might as well
  put the kobject as part of 'struct intel_gt' and that also removes the
  need to have a 'struct kobj_gt' (kobj_to_gt() can just use container_of()
  to get gt from kobj).
* So I think this patch simpler/cleaner than the original code if you take
  the requirement for kobject_put() into account.

Thanks.
--
Ashutosh
